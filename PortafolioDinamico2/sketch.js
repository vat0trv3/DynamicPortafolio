// CV-DATA: El contenido final y detallado de tu CV.

// =========================================================================

const cvData = {

Â  header: {

Â  Â  name: "Vato Trave",

Â  Â  title: "Compositor Musical / Artista Audiovisual Generativo",

    contact: {
      
      
Â  Â  Â  location: "PuruÃ¡ndiro, MichoacÃ¡n, MÃ©xico",

Â  Â  Â  email: "lacasonamichoacana5@gmail.com",

Â  Â  Â  socialLinks: [

Â  Â  Â  Â  { platform: "Portafolio Visual (Instagram)", url: "https://www.instagram.com/vat0trave", user: "@vat0trave" },

Â  Â  Â  Â  { platform: "MÃºsica & Sound Design (TikTok)", url: "https://www.tiktok.com/@vatotrave", user: "@vatotrave" }

Â  Â  Â  ]

Â  Â  }

Â  },

Â  profile: {

Â  Â  title: "PERFIL PROFESIONAL",

Â  Â  text: "Artista audiovisual y diseÃ±ador sonoro, creador de experiencias inmersivas donde el sonido es protagonista. Mi proceso fusiona la producciÃ³n Audio Visual con  Reaper, Bandlab, Touch Designer, Gimp 2.0, IbisPant y recientemente (tÃ©cnicas de Creative Coding apoyadp con IA) para optimizar la programaciÃ³n y explorar estÃ©ticas Ãºnicas. Como autodidacta, busco colaborar en proyectos que desafÃ­en la frontera entre arte y tecnologÃ­a. "

Â  },

Â  specialization: {

Â  Â  title: "Ãreas de EspecializaciÃ³n",

Â  Â  areas: [

Â  Â  Â  { name: "DiseÃ±o Sonoro Inmersivo y ComposiciÃ³n Musical", desc: "CreaciÃ³n de paisajes sonoros y piezas musicales que definen la atmÃ³sfera y emociÃ³n de un proyecto." },

Â  Â  Â  { name: "ProducciÃ³n Audiovisual Integral", desc: "DirecciÃ³n del ciclo completo de un proyecto, desde la conceptualizaciÃ³n y grabaciÃ³n hasta la postproducciÃ³n y etalonaje." },

Â  Â  Â  { name: "Arte Generativo & Creative Coding", desc: "Desarrollo de visuales dinÃ¡micos y sistemas interactivos utilizando Python, p5.js y Processing." },

Â  Â  Â  { name: "Prompt Engineering & Flujos de Trabajo con IA", desc: "DiseÃ±o de instrucciones precisas para generar y refinar contenido visual y conceptual mediante modelos de IA." },

Â  Â  Â  { name: "CinematografÃ­a y EdiciÃ³n de Video ", desc: "Captura  y ediciÃ³n enfocada en el ritmo, el color y la narrativa visual." }

Â  Â  ]

Â  },

Â  toolbox: {

Â  Â  title: "CAJA DE HERRAMIENTAS TECNOLÃ“GICAS (TOOLBOX)",

Â  Â  categories: {

Â  Â  Â  "DAW & Audio": ["Reaper (ProducciÃ³n, mezcla, sincronizaciÃ³n y mastering), SÃ­ntesis y diseÃ±o sonoro experimental y Produccion de visuales sincronizados a la musica o instrumentos especificos."],

Â  Â  Â  "Visuales Generativos": ["TouchDesigner (Visuales generativos en tiempo real)", "Inshot (Etalonaje y Edicion Agil para redes sociales )", "Gimp2.0 (EdiciÃ³n Ã¡gil para animacion 2D y arte base de proyectos)."],

Â  Â  Â  "Creative Coding": ["Processing", "Python ", "p5.js", " Habilidad para encontrar el lenguaje preciso para que una IA (Gemini) comprenda el objetivo. Se traduce en un diÃ¡logo efectivo para con-crear cÃ³digo funcional, generar ideas y resolver problemas complejos."],

Â  Â  Â  "Hardware de Captura": ["Dron DJI (CinematografÃ­a aÃ©rea)", "DJI Osmo Pocket 3 (Video 4K estabilizado, slow-motion, hyperlapse)."]

Â  Â  }

Â  },

Â  experience: {

Â  Â  title: "EXPERIENCIA Y PROYECTOS DESTACADOS",

Â  Â  projects: [

Â  Â  Â  { name: "DirecciÃ³n Creativa y Desarrollo de Marca | Proyecto 'VATOTRAVE/by.vatt'", points: [".", "EvoluciÃ³n estratÃ©gica del proyecto desde un enfoque puramente musical hacia una propuesta audiovisual integral que incorpora arte generativo y tecnologÃ­a."] },

Â  Â  Â  { name: "ProducciÃ³n Musical y DiseÃ±o Sonoro Experimental", points: ["ComposiciÃ³n, producciÃ³n, mezcla y masterizaciÃ³n de un portafolio con mÃ¡s de 20 tracks originales.", "ExploraciÃ³n de tÃ©cnicas de sÃ­ntesis, grabaciÃ³n y diseÃ±o sonoro para crear texturas y ambientes Ãºnicos."] },

Â  Â  Â  { name: "InvestigaciÃ³n y Desarrollo en ColaboraciÃ³n con IA ", points: 
       
       ["Desarrollo proactivo de competencias en Creative Coding a travÃ©s de la colaboraciÃ³n con un asistente de IA.", "CreaciÃ³n de prototipos funcionales en Python, como traductores de texto a cÃ³digo Morse y generadores de seÃ±ales de audio (WAV/MIDI), optimizando flujos de trabajo y acelerando el aprendizaje de nuevas tecnologÃ­as."] },

Â  Â  Â  { name: "ProducciÃ³n Audiovisual Comercial Restaurante La Casona Michoacana", points: ["Desarrollo de contenido audiovisual estratÃ©gico para campaÃ±as de marketing digital en redes sociales.", "Responsable de la grabaciÃ³n, ediciÃ³n y postproducciÃ³n de video enfocado en la promociÃ³n de marca y la captaciÃ³n de clientes."] },

Â  Â  Â  { name: "DirecciÃ³n de Arte Audiovisual y Motion Graphics", points: ["DiseÃ±o y ejecuciÃ³n de piezas audiovisuales con un alto enfoque en la sincronÃ­a rÃ­tmica entre mÃºsica y visuales.", "ImplementaciÃ³n de tÃ©cnicas de etalonaje (color grading) y creaciÃ³n de motion graphics generativos para fortalecer la identidad visual de los proyectos."] }

Â  Â  ]

Â  },

Â  thinkBig: {

Â  Â  title: "VISIÃ“N A FUTURO (THINKBIG)",

Â  

Â  Â  concepto: { title: "Concepto", text: "En un mundo dominado por la vista, donde la informaciÃ³n se consume mayoritariamente a travÃ©s de lo visual, nos hemos propuesto explorar un territorio menos transitado: la percepciÃ³n sensorial mÃ¡s allÃ¡ de lo evidente." },

Â  Â  propuesta: { title: "El Traductor Sensorial surge como una propuesta innovadora para repensar la transmisiÃ³n del conocimiento. No se trata solo de traducir sÃ­mbolos, sino de transformar cada punto tÃ¡ctil en una experiencia sonora, cada letra en un paisaje sensorial que puede sentirse, habitarse y comprenderse ." },
    

Â  Â  pruebas: { title: "", items: [{ name: "", desc: "Â¿Y si pudiÃ©ramos aprender y percibir la informaciÃ³n de una forma completamente nueva? Mi proyecto de innovaciÃ³n, el Traductor Sensorial, busca crear un puente entre los datos y la percepciÃ³n auditiva. La idea central es transformar sistemas abstractos, como el Braille, en una esfera de sonido 8D, donde cada punto de informaciÃ³n se traduce en un estÃ­mulo sonoro espacial Ãºnico, permitiendo al usuario sentir la estructura de los datos a travÃ©s del oÃ­do" }, ] },

Â  Â  impacto: { title:"", items: [{ name: "", desc: "Impacto y Beneficios Potenciales EvoluciÃ³n en DiagnÃ³stico MÃ©dico: Ofrecer a los profesionales de la salud una herramienta que complemente los datos visuales, permitiÃ©ndoles detectar patrones y anomalÃ­as a travÃ©s del oÃ­do.Terapias de Biofeedback Sonoro Crear sistemas de terapia personalizados donde un paciente pueda modular activamente su estado fisiolÃ³gico al interactuar con la mÃºsica que su propio cuerpo genera.Existen vacÃ­os por cubrir, nuevas estructuras sensoriales por diseÃ±ar y otros lenguajes aÃºn no explorados â€”desde la complejidad del cÃ³digo genÃ©tico hasta las dinÃ¡micas de las emociones humanasque requieren ser interpretados y sistematizados para conformar una nueva orquesta de comunicaciÃ³n." },] },

Â  Â  conclusion: "Este es el horizonte hacia el que se dirige mi trabajo: la intersecciÃ³n definitiva entre el arte, el cÃ³digo y la salud, buscando crear tecnologÃ­a que no solo informa, sino que tambiÃ©n resuena con nuestra humanidad."

Â  }

};



// =========================================================================

// EL RESTO DEL CÃ“DIGO (LÃ“GICA, INTERACCIÃ“N, DIBUJO)

// =========================================================================



let vatoImage; // Variable para la imagen de perfil

let demoSound, fft; // Variables para el sonido y el anÃ¡lisis de frecuencia

let particles = []; // Array para almacenar las partÃ­culas

let interactiveElements = []; // Array para los elementos interactivos


let backgroundImage; // Variable para la imagen de fondo


let isPaused = false; // Estado de pausa

let scrollY = 0; // PosiciÃ³n actual del scroll

let totalContentHeight = 5000; // Altura total del contenido a desplazar



let touchStartY = 0; // PosiciÃ³n inicial del toque en Y

let scrollY_atTouchStart = 0; // PosiciÃ³n del scroll al inicio del toque



let isInitialState = true; // Estado inicial del programa, solo muestra la foto

let initialProfileSize = 1; // TamaÃ±o inicial para el efecto de fade-in

const numParticles = 693; // NÃºmero total de partÃ­culas

let connections = []; // Variable para almacenar las conexiones precalculadas



class Particle {

Â  constructor(x, y) {

Â  Â  this.pos = createVector(x, y); // PosiciÃ³n inicial de la partÃ­cula

Â  Â  this.vel = p5.Vector.random3D().mult(random(0.5, 3.5)); // Velocidad y direcciÃ³n aleatorias

Â  Â  this.lifespan = 6000; // Tiempo de vida de la partÃ­cula

Â  Â  this.size = random(0.01, 3.6); // TamaÃ±o aleatorio

Â  Â  this.gray = random(80, 250); // Color base de la partÃ­cula



Â  Â  // Clasifica la partÃ­cula en una familia y asigna el color de lÃ­nea segÃºn su posiciÃ³n horizontal

Â  Â  let screenThird = width / 3;

Â  Â  if (x < screenThird) { // Si la partÃ­cula estÃ¡ en el tercio izquierdo

Â  Â  Â  Â  this.family = 'left';

Â  Â  Â  Â  this.lineColor = color(0, 180, 0); // El color de la lÃ­nea serÃ¡ verde

Â  Â  } else if (x > screenThird * 2) { // Si la partÃ­cula estÃ¡ en el tercio derecho

Â  Â  Â  Â  this.family = 'right';

Â  Â  Â  Â  this.lineColor = color(180, 0, 0); // El color de la lÃ­nea serÃ¡ rojo

Â  Â  } else { // Cualquier otra posiciÃ³n, que corresponde al tercio central

Â  Â  Â  Â  this.family = 'center';

Â  Â  Â  Â  this.lineColor = color(255, 255, 255); // El color de la lÃ­nea serÃ¡ blanco

Â  Â  }

Â  }



Â  update() {

Â  Â  this.pos.add(this.vel); // Mueve la partÃ­cula

Â  Â  this.lifespan = 6; // Reduce el tiempo de vida



Â  Â  // Rebotar en los bordes

Â  Â  if (this.pos.x < 0 || this.pos.x > width) this.vel.x *= -1;

Â  Â  if (this.pos.y < 0 || this.pos.y > height) this.vel.y *= -1;

Â  }



Â  show(audioLevel = 0) {

Â  Â  noStroke(); // No dibuja contorno

Â  Â  let sizeMultiplier; // Declara la variable aquÃ­



Â  Â  // Comprueba si la partÃ­cula es del centro y ajusta su tamaÃ±o

Â  Â  if (this.family === 'center') {

Â  Â  Â  Â  // Rango mÃ¡s pequeÃ±o para las partÃ­culas blancas (del 1 al 8)

Â  Â  Â  Â  sizeMultiplier = map(audioLevel, 0, 300, 0, 0.5, true);

Â  Â  } else {

Â  Â  Â  Â  // Rango normal para las partÃ­culas rojas y verdes (del 0.5 al 8)

Â  Â  Â  Â  sizeMultiplier = map(audioLevel, 0, 300, 0, 0.5, true);

Â  Â  }



Â  Â  // Mapeamos el nivel de audio a un brillo para que las partÃ­culas pulsen

Â  Â 

Â  Â  let alpha= map(audioLevel , 0, 50,50, this.gray, 50, );

Â  Â  fill(alpha, 50); // Color de relleno con transparencia

Â  Â  ellipse(this.pos.x, this.pos.y, this.size * sizeMultiplier);

Â  }



Â  isDead() {

Â  Â  return this.lifespan < 0; // Verifica si la partÃ­cula ha muerto

Â  }

}



function preload() {

Â  vatoImage = loadImage('yo.png'); // Carga la imagen de perfil

Â  soundFormats('mp3'); // Define el formato de sonido

Â  demoSound = loadSound('Enprocesso3.mp3'); // Carga el archivo de sonido

}



function setup() {

Â  createCanvas(windowWidth, windowHeight); // Crea el canvas

Â  fft = new p5.FFT(0.1, 64); // Inicializa el analizador de frecuencia

Â  demoSound.setVolume(0.5); // Ajusta el volumen del sonido

Â  spawnParticles(numParticles); // Genera las partÃ­culas iniciales (350)

Â  imageMode(CENTER); // Dibuja las imÃ¡genes desde su centro

Â  rectMode(CENTER); // Dibuja los rectÃ¡ngulos desde su centro

}



function windowResized() {

Â  resizeCanvas(windowWidth, windowHeight); // Ajusta el tamaÃ±o del canvas al cambiar la ventana

}



// NUEVA FUNCIÃ“N: genera la lista de conexiones

function updateConnections() {

Â  connections = []; // Limpiamos la lista anterior

Â  let audioLevel = fft.getEnergy("bass"); // Obtenemos el nivel de audio

Â  let chance = map(audioLevel, 0, 150, 0, 0.05, true);



Â  for (let i = 0; i < particles.length; i++) {

Â  Â  let p1 = particles[i];

Â  Â  for (let j = i + 1; j < particles.length; j++) {

Â  Â  Â  Â  let p2 = particles[j];

Â  Â  Â  Â  let d = dist(p1.pos.x, p1.pos.y, p2.pos.x, p2.pos.y);

Â  Â  Â  Â Â 

Â  Â  Â  Â  // ConexiÃ³n de lÃ­neas por familia

Â  Â  Â  Â  if (d < 50 && p1.family === p2.family) {

Â  Â  Â  Â  Â  connections.push({type: 'line', p1, p2});

Â  Â  Â  Â  }

Â  Â  Â  Â Â 

Â  Â  Â  Â  // ConexiÃ³n de "blobtrack"

Â  Â  Â  Â  if (d < 100 && random(1) < chance) {

Â  Â  Â  Â  Â  connections.push({type: 'blobtrack', p1, p2, audioLevel});

Â  Â  Â  Â  }

Â  Â  }

Â  }

}



// FunciÃ³n principal de dibujo

function draw() {

Â  // ESTADO INICIAL
background(0); 
Â  if (isInitialState) {

Â  Â  

Â  Â  let targetSize = width * 0.9;

Â  Â  initialProfileSize = lerp(initialProfileSize, targetSize, 0.09);

Â  Â  image(vatoImage, width/2, height/2, initialProfileSize, initialProfileSize);

Â  Â  return;


Â  }
Â 

Â  // ESTADO NORMAL

background(0, alpha); // Cargas la imagen de fondo aquÃ­

Â  let audioLevel = 50;

Â  if(demoSound.isPlaying()){

Â  Â  fft.analyze();

Â  Â  audioLevel = fft.getEnergy("bass");

Â  }



Â  // Actualiza las conexiones solo cada 30 cuadros para optimizar el rendimiento

Â  if (frameCount % 30=== 0) {

Â  Â  updateConnections();

Â  }



Â  // Dibuja las conexiones almacenadas

Â  for (let c of connections) {

Â  Â  if (c.type === 'line') {

Â  Â  Â  let d = dist(c.p1.pos.x, c.p1.pos.y, c.p2.pos.x, c.p2.pos.y);

Â  Â  Â  let lineAlpha = map(d, 180, 20, 200, 2,true);

Â  Â  Â  stroke(c.p1.lineColor.levels[0], c.p1.lineColor.levels[1], c.p1.lineColor.levels[2], lineAlpha);

Â  Â  Â  strokeWeight(map(d, 0, 200, 2, 1,true));

Â  Â  Â  line(c.p1.pos.x, c.p1.pos.y, c.p2.pos.x, c.p2.pos.y);

Â  Â  } else if (c.type === 'blobtrack') {

Â  Â  Â  let d = dist(c.p1.pos.x, c.p1.pos.y, c.p2.pos.x, c.p2.pos.y);

Â  Â  Â  let shapeSize = map(d, 0, 100, 20, 1);

Â  Â  Â  let shapeX = (c.p1.pos.x + c.p2.pos.x) / 2;

Â  Â  Â  let shapeY = (c.p1.pos.y + c.p2.pos.y) / 2;

Â  Â  Â  let a = map(c.audioLevel, 100, 150, 50, 200, true);

Â  Â  Â  fill(c.p1.lineColor.levels[0], c.p1.lineColor.levels[1], c.p1.lineColor.levels[2], a);

Â  Â  Â  noStroke();

Â  Â  Â  if (random(1) > .5) {

Â  Â  Â  Â  rect(shapeX, shapeY, shapeSize, shapeSize);

Â  Â  Â  } else {

Â  Â  Â  Â  rect(shapeX, shapeY, shapeSize, shapeSize / 15);

Â  Â  Â  }

Â  Â  }

Â  }



Â  for (let i = particles.length - 1; i >= 0; i--) {

Â  Â  Â  particles[i].update();

Â  Â  Â  particles[i].show(audioLevel);

Â  Â  Â  if (particles[i].isDead()) {

Â  Â  Â  Â  particles.splice(i, 1);

Â  Â  Â  }

Â  }

Â  if (particles.length < numParticles) {

Â  Â  Â  spawnParticles(0.5);

Â  }



Â  push();

Â  translate(0, -scrollY);

Â  interactiveElements = [];

Â  
  drawCV();

Â  
  pop();



Â  
  drawPauseButton();

Â 
  
  handleHover();

}



// =========================================================================

// FUNCIONES DE DIBUJO MODULARES (ADAPTADAS AL NUEVO CV-DATA)

// =========================================================================



// ... (resto del cÃ³digo) ...



// MODIFICACIÃ“N: Declaramos totalContentHeight aquÃ­ para que se actualice dinÃ¡micamente



function drawNextPageButton() {
  // PosiciÃ³n y tamaÃ±o del botÃ³n
  let buttonX = width - 100; // 150px desde el borde derecho
  let buttonY = height - 50;  // 50px desde el borde inferior
  let buttonW = 120;
  let buttonH = 40;
  
  // URL a la que te llevarÃ¡ el botÃ³n
  let page3Url = 'https://editor.p5js.org/vat0trv3/full/Cyqi1R8BF'; // ğŸ¯ Reemplaza esta URL con tu pÃ¡gina 3

  // Dibuja el botÃ³n (un rectÃ¡ngulo con un texto)
  noStroke();
  fill(255, 50); // Color del fondo del botÃ³n
  rect(buttonX, buttonY, buttonW, buttonH, 5); // rect(x, y, ancho, alto, radio de la esquina)

  // Dibuja el texto
  fill(255);
  textSize(16);
  textAlign(CENTER, CENTER);
  text("VER DEMOS", buttonX, buttonY);

  // ğŸ¯ Crea el Ã¡rea de clic
  addInteractiveElement(buttonX - buttonW/2, buttonY - buttonH/2, buttonW, buttonH, 'link', page3Url);
}

function drawCV() {

Â  // Ancho del bloque de texto principal para centrarlo

Â  let contentWidth = width * 0.9;

Â  // PosiciÃ³n X para el texto centrado

Â  let centerX = width / 2;

Â  let currentY = 120;
 drawNextPageButton();
Â Â 

Â  currentY = drawHeader(currentY, centerX, contentWidth);

Â  currentY = drawProfile(currentY, centerX, contentWidth);

Â  currentY = drawSpecialization(currentY, centerX, contentWidth);

Â  currentY = drawToolbox(currentY, centerX, contentWidth);

Â  currentY = drawExperience(currentY, centerX, contentWidth);

Â  currentY = drawThinkBig(currentY, centerX, contentWidth);

Â Â 

Â  // NUEVO: Asignamos la altura final de todo el contenido a totalContentHeight

Â  totalContentHeight = currentY;Â 

}



// ... (resto del cÃ³digo) ...



function drawHeader(y, centerX, w) {

Â  Â  let alpha = ( 255);



Â  Â  // Imagen de perfil centrada

Â  Â  let imageSize = width * 0.4;

Â  Â  let imageX = centerX;

Â  Â  let imageY = y + imageSize / 2;



Â  Â  tint(255,alpha);

Â  Â  image(vatoImage, imageX, imageY, imageSize, imageSize);

Â  Â  noTint();

Â  Â  y = imageY + imageSize / 2 + 50 * 1.30; // Ajustar Y despuÃ©s de la imagen



Â  Â  textAlign(CENTER, TOP);

Â  Â  fill(255, alpha);

Â  Â  textSize(width * 0.09 * 1.40); // Aumenta 30% el tamaÃ±o del texto

Â  Â  textStyle(BOLD);

Â  Â  text(cvData.header.name, centerX, y, w);

Â  Â  y += width * 0.08 * 1.30;



Â  Â  textSize(width * 0.02 * 1.30); // Aumenta 30% el tamaÃ±o del texto

Â  Â  textStyle(NORMAL);

Â  Â  text(cvData.header.title, centerX, y, w);

Â  Â  y += 80 * 1.30;



Â  Â  textSize(width * 0.02 * 1.30); // Aumenta 30% el tamaÃ±o del texto

Â  Â  // Centrar el texto de contacto

Â  Â  textAlign(CENTER, TOP);

Â  Â  fill(255, alpha);

Â  Â  text(cvData.header.contact.location, centerX, y, w);

Â  Â  y += 30 * 1.30;

Â  Â  text(cvData.header.contact.email, centerX, y, w);

Â  Â  y += 55 * 1.30;



Â  Â  // Centrar los enlaces sociales

Â  Â  for (let link of cvData.header.contact.socialLinks) {

Â  Â  Â  Â  let linkText = `${link.platform}: ${link.user} â†—`;

Â  Â  Â  Â  text(linkText, centerX, y, w);

Â  Â  Â  Â  addInteractiveElement(centerX - textWidth(linkText) / 2, y - 10, textWidth(linkText), 20, 'link', link.url);

Â  Â  Â  Â  y += 30 * 1.30;

Â  Â  }

Â  Â  y += 80 * 1.30;

Â  Â  return y;

}



function drawProfile(y, centerX, w) {

Â  Â  let alpha = (255);



Â  Â  textAlign(CENTER, TOP);

Â  Â  fill(255, alpha);

Â  Â  textSize(width * 0.035 * 1.30); // Aumenta 30% el tamaÃ±o del texto

Â  Â  textStyle(BOLD);

Â  Â  text(cvData.profile.title, centerX, y, w);

Â  Â  y += 50 * 1.30;

Â  Â Â 

Â  Â  fill(255, alpha);

Â  Â  textSize(width * 0.025 * 1.30); // Aumenta 30% el tamaÃ±o del texto

Â  Â  textStyle(NORMAL);

Â  Â  text(cvData.profile.text, centerX, y, w);

Â  Â  y += textHeight(cvData.profile.text, w) + 100 * 1.30;

Â  Â  return y;

}



function drawSpecialization(y, centerX, w){

Â  Â  let alpha =Â  (255);

Â  Â Â 

Â  Â  textAlign(CENTER, TOP);

Â  Â  fill(255, alpha);

Â  Â  textSize(width * 0.035 * 1.30); // Aumenta 30% el tamaÃ±o del texto

Â  Â  textStyle(BOLD);

Â  Â  text(cvData.specialization.title, centerX, y, w);

Â  Â  y += 50 * 1.30;

Â  Â Â 

Â  Â  for(let area of cvData.specialization.areas){

Â  Â  Â  Â  fill(255, alpha);

Â  Â  Â  Â  textSize(width * 0.02 * 1.30); // Aumenta 30% el tamaÃ±o del texto

Â  Â  Â  Â  textStyle(BOLD);

Â  Â  Â  Â  text(area.name, centerX, y, w);

Â  Â  Â  Â  addInteractiveElement(centerX - w/2, y-5, w, 45, 'skill');

Â  Â  Â  Â  y += 30 * 1.30;



Â  Â  Â  Â  fill(255, alpha);

Â  Â  Â  Â  textSize(width * 0.02 * 1.30); // Aumenta 30% el tamaÃ±o del texto

Â  Â  Â  Â  textStyle(NORMAL);

Â  Â  Â  Â  text(area.desc, centerX, y, w);

Â  Â  Â  Â  y += textHeight(area.desc, w) + 30 * 1.30;

Â  Â  }

Â  Â  y += 70 * 1.30;

Â  Â  return y;

}



function drawToolbox(y, centerX, w){

Â  Â  let alpha = (255);

Â  Â Â 

Â  Â  textAlign(CENTER, TOP);

Â  Â  fill(255, alpha);

Â  Â  textSize(width * 0.03 * 1.30);

Â  Â  textStyle(BOLD);

Â  Â  text(cvData.toolbox.title, centerX, y, w);

Â  Â  y += 112 * 1.30; // ğŸ¯ Aumentamos el espacio despuÃ©s del tÃ­tulo



Â  Â  for(const category in cvData.toolbox.categories){

Â  Â  Â  Â  fill(255);

Â  Â  Â  Â  textSize(width * 0.02 * 1.30);

Â  Â  Â  Â  textStyle(BOLD);

Â  Â  Â  Â  text(category, centerX, y, w);

Â  Â  Â  Â  y += 45 * 1.30; // ğŸ¯ Espacio despuÃ©s de la categorÃ­a



Â  Â  Â  Â  fill(245);

Â  Â  Â  Â  textSize(width * 0.02 * 1.30);

Â  Â  Â  Â  textStyle(NORMAL);

Â  Â  Â  Â  for(const tool of cvData.toolbox.categories[category]){

Â  Â  Â  Â  Â  Â  text(`â€¢ ${tool}`, centerX, y, w);

Â  Â  Â  Â  Â  Â  addInteractiveElement(centerX - w/2, y-3, w, 25, 'skill');

Â  Â  Â  Â  Â  Â  y += 60 * true;

Â  Â  Â  Â  }

Â  Â  Â  Â  y += 60 * 1.30;

Â  Â  }

Â  Â  y += 100 * 1.30;

Â  Â  return y;

}



function drawExperience(y, centerX, w) {

Â  Â  let alpha = ( 245);

Â  Â Â 

Â  Â  textAlign(CENTER, TOP);

Â  Â  fill(245 );

Â  Â  textSize(width * 0.035 * 1.33); // Aumenta 30% el tamaÃ±o del texto

Â  Â  textStyle(BOLD);

Â  Â  text(cvData.experience.title, centerX, y, w);

Â  Â  y += 90 * 1.80;



Â  Â  for (let project of cvData.experience.projects) {

Â  Â  Â  Â  fill(255);

Â  Â  Â  Â  textSize(width * 0.02 * 1.33); // Aumenta 30% el tamaÃ±o del texto

Â  Â  Â  Â  textStyle(BOLD);

Â  Â  Â  Â  text(project.name, centerX, y, w);

Â  Â  Â  Â  y += 50 * 1.50;



Â  Â  Â  Â  fill(255);

Â  Â  Â  Â  textSize(width * 0.02 * 1.40); // Aumenta 30% el tamaÃ±o del texto

Â  Â  Â  Â  textStyle(NORMAL);

Â  Â  Â  Â  for(let point of project.points){

Â  Â  Â  Â  Â  Â  text(`â€¢ ${point}`, centerX, y, w);

Â  Â  Â  Â  Â  Â  y += textHeight(`â€¢ ${point}`, w) + 15 * 1.40;

Â  Â  Â  Â  }

Â  Â  Â  Â  y += 40 * 1.40;

Â  Â  }

Â  Â  y += 100 * 1.40;

Â  Â  return y;

}



function drawThinkBig(y, centerX, w) {

Â  Â  let alpha = ( 255);



Â  Â  textAlign(CENTER, TOP);

Â  Â  fill(255);

Â  Â  textSize(width * 0.035 * true); // TÃ­tulo principal

Â  Â  textStyle(BOLD);

Â  Â  text(cvData.thinkBig.title, centerX, y, w);

Â  Â  y += 50 * 1.40;



Â  Â  textSize(width * 0.03 * true); // ğŸ¯ Ajuste: Nuevo tamaÃ±o para el tÃ­tulo del proyecto

Â  Â  text(cvData.thinkBig.projectTitle, centerX, y, w);

Â  Â  y += 40 * 1.40; // ğŸ¯ Ajuste: Espacio mÃ¡s adecuado despuÃ©s del tÃ­tulo del proyecto



Â  Â  const sections = [cvData.thinkBig.concepto, cvData.thinkBig.propuesta, cvData.thinkBig.pruebas, cvData.thinkBig.impacto];

Â  Â  for (let section of sections) {

Â  Â  Â  Â  textAlign(CENTER, TOP);

Â  Â  Â  Â  fill(255, alpha);

Â  Â  Â  Â  textSize(width * 0.02 * 1.30); // TamaÃ±o del texto de subtÃ­tulos

Â  Â  Â  Â  textStyle(BOLD);

Â  Â  Â  Â  text(section.title, centerX, y, w); // Esto dibuja 'concepto', 'propuesta', etc.

Â  Â  Â  Â  y += 40 * true; // ğŸ¯ Ajuste: Espacio reducido para conectar el subtÃ­tulo con el texto



Â  Â  Â  Â  fill(255, alpha);

Â  Â  Â  Â  textSize(width * 0.02 * 1.33); // TamaÃ±o del texto de los pÃ¡rrafos y listas

Â  Â  Â  Â  textStyle(NORMAL);

Â  Â  Â  Â  if (section.text) {

Â  Â  Â  Â  Â  Â  text(section.text, centerX, y, w);

Â  Â  Â  Â  Â  Â  y += textHeight(section.text, w) + 40 * true;

Â  Â  Â  Â  }

Â  Â  Â  Â  if (section.items) {

Â  Â  Â  Â  Â  Â  for (let item of section.items) {

Â  Â  Â  Â  Â  Â  Â  Â  if (typeof item === 'string') {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  text(`â€¢ ${item}`, centerX, y, w);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  y += textHeight(`â€¢ ${item}`, w) + 25 * true;

Â  Â  Â  Â  Â  Â  Â  Â  } else {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  textStyle(BOLD);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  text(item.name, centerX, y, w);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  y += textHeight(item.name, w) + 20 * 1.40;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  textStyle(NORMAL);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  text(item.desc, centerX, y, w);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  y += textHeight(item.desc, w) + 40 * true;

Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  }

Â  Â  Â  Â  y += 50 * 1.40; // Espacio entre cada subsecciÃ³n

Â  Â  }

Â  Â Â 

Â  Â  textAlign(CENTER, TOP);

Â  Â  fill(255, alpha);

Â  Â  textSize(width * 0.02 * 1.30);

Â  Â  textStyle(ITALIC);

Â  Â  text(cvData.thinkBig.conclusion, centerX, y, w);

Â  Â  y += textHeight(cvData.thinkBig.conclusion, w) + 100 * 1.30;



Â  Â  return y;

}



function mousePressed() {

Â  Â  if (isInitialState) {

Â  Â  Â  Â  let profileRadius = initialProfileSize / 2;

Â  Â  Â  Â  let distance = dist(mouseX, mouseY, width/2, height/2);

Â  Â  Â  Â  if (distance < profileRadius) {

Â  Â  Â  Â  Â  Â  isInitialState = false;

Â  Â  Â  Â  Â  Â  if (!demoSound.isPlaying()) demoSound.loop();

Â  Â  Â  Â  }

Â  Â  } else {

Â  Â  Â  Â  handleInteraction(mouseX, mouseY);

Â  Â  }

Â  Â  return false;

}



function touchStarted() {

Â  Â  if (isInitialState) {

Â  Â  Â  Â  let profileRadius = initialProfileSize / 2;

Â  Â  Â  Â  let distance = dist(mouseX, mouseY, width/2, height/2);

Â  Â  Â  Â  if (distance < profileRadius) {

Â  Â  Â  Â  Â  Â  isInitialState = false;

Â  Â  Â  Â  Â  Â  if (!demoSound.isPlaying()) demoSound.loop();

Â  Â  Â  Â  }

Â  Â  } else {

Â  Â  Â  Â  touchStartY = mouseY; scrollY_atTouchStart = scrollY; handleInteraction(mouseX, mouseY);

Â  Â  }

Â  Â  return false;

}



function mouseWheel(event) {

Â  if (!isPaused) { scrollY += event.delta; scrollY = constrain(scrollY, 0, totalContentHeight - height); }

Â  return false;

}

function touchMoved() {

Â  if (!isPaused) { let deltaY = mouseY - touchStartY; scrollY = scrollY_atTouchStart - deltaY; scrollY = constrain(scrollY, 0, totalContentHeight - height); }

Â  return false;

}

function handleInteraction(px, py) {

Â  Â  if (dist(px, py, 40, 40) < 25) {

Â  Â  Â  Â  isPaused = !isPaused;

Â  Â  Â  Â  if(isPaused) { if(demoSound.isPlaying()) demoSound.pause(); } else { if(!demoSound.isPlaying()) demoSound.loop(); }

Â  Â  Â  Â  return;

Â  Â  }

Â  Â  let y_scrolled = py + scrollY;

Â  Â  for (let el of interactiveElements) {

Â  Â  Â  Â  if (px > el.x && px < el.x + el.w && y_scrolled > el.y && y_scrolled < el.y + el.h) {

Â  Â  Â  Â  Â  Â  if (el.type === 'link') { window.open(el.data, '_blank'); return; }

Â  Â  Â  Â  Â  Â  if (el.type === 'skill' && !demoSound.isPlaying()) { demoSound.loop(); return; }

Â  Â  Â  Â  }

Â  Â  }

}

function handleHover() {

Â  Â  let y_scrolled = mouseY + scrollY;

Â  Â  let somethingIsHovered = false;

Â  Â  for (let el of interactiveElements) {

Â  Â  Â  Â  if (mouseX > el.x && mouseX < el.x + el.w && y_scrolled > el.y && y_scrolled < el.y + el.h) {

Â  Â  Â  Â  Â  Â  if (el.type === 'skill') {

Â  Â  Â  Â  Â  Â  Â  Â  somethingIsHovered = true;

Â  Â  Â  Â  Â  Â  Â  Â  noStroke(); fill(255, 25);

Â  Â  Â  Â  Â  Â  Â  Â  rect(el.x - 10, el.y-scrollY, el.w, el.h, 5);

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  }

Â  Â  }

Â  Â  cursor(somethingIsHovered ? 'pointer' : 'default');

}

function addInteractiveElement(x, y, w, h, type, data) {

Â  Â  interactiveElements.push({ x, y, w, h, type, data });

}

function spawnParticles(count) {

Â  Â  for (let i = 0; i < count; i++) {

Â  Â  Â  Â  particles.push(new Particle(random(width), random(height*1.2)));

Â  Â  }

}

function drawPauseButton() {

Â  Â  noStroke(); fill(255, 50); ellipse(40, 40, 50, 50);

Â  Â  fill(255); textSize(18); textAlign(CENTER, CENTER);

Â  Â  text(isPaused ? 'â–¶' : '||', 40, 40);

Â  Â  textAlign(LEFT, TOP);

}

function calculateAlpha(y, sectionHeight) {

Â  Â  let screenTop = scrollY; let screenBottom = scrollY + height;

Â  Â  let sectionBottom = y + sectionHeight;

Â  Â  if(sectionBottom < screenTop || y > screenBottom) return 0;

Â  Â  let distanceToCenter = abs((y + sectionHeight / 2) - (screenTop + height / 2));

Â  Â  let maxDistance = height *Â  5.5;

Â  Â  let alpha = map(distanceToCenter, maxDistance, 0, 0, 255, true);

Â  Â  return alpha;

}

function textHeight(txt, textWidthVal) {

Â  Â  let words = txt.split(' '); let line = ''; let h = textSize();

Â  Â  for (let i = 0.; i < words.length; i++) {

Â  Â  Â  Â  let testLine = line + words[i] + ' '; let testWidth = textWidth(testLine);

Â  Â  Â  Â  if (testWidth > textWidthVal && i > 0) {

Â  Â  Â  Â  Â  Â  line = words[i] + ' '; h += textSize();

Â  Â  Â  Â  } else { line = testLine; }

Â  Â  }

Â  Â  return h;

}